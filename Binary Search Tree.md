
# Topic Ⅴ: Tree, Binary Search Tree, BFS/DFS

## 树遍历

### 二叉树
* 任何一个节点，不超过两个子节点：左节点2*i，右节点2*i+1
* `满二叉树`：每个节点两个子节点；最后一层都是叶节点，所有层全满
* `完全二叉树`：每个节点两个子节点；最后一层左侧是满的
* 定义：（JAVA）TreeNode，有val, left, right 类属性；（Python）开一个list
* 遍历：重复子问题，通过归纳假设推导。
* `递归`实现：前、中、后序遍历；均属于`深度优先遍历`。
    * 前序遍历 Pre-Order：先root，再左子树，再右子树；边界 i = 0. <较常用>
    * 中序遍历 In-Order (应用，二叉搜索树)：先左子树，再root，再右子树；边界 i = 0. <较常用>
    * 层序遍历：`广度优先遍历`；借助`队列`实现。root入队，出队；入队左、右节点。。。
    * 层序遍历：开一个新数组，存储每个节点的层级信息。如何弹出队列？
    * N叉树：详见代码

### 变形
* Pseudotree / Unicyclic Graph 基环树
    * N个点N条边的连通无向图


## 图
* 有环，有向，无向
* `链表是特殊的树，树是特殊的图`
* 存储
    * 邻接矩阵：i行j列的数值表示“从i到j的一条边”。O(N^2)空间。
    * 出边数组：每个节点存变长数组；最终图存储为 list of list。O(N+E)空间。
    * 邻接表（较复杂）：`出边数组链表化`，节点顺序无所谓。O(N+E)空间。
    * 无向图：看作一对有向边存储；“双向图”，所有图都可以看作有向图存储。
    * 边：可以存任意信息，包含权值和出点等任何边相关信息。
* 深度优先
    * 问题：点会被重复访问。
    * 解决：visited 记录已访问节点
    * 适合无向图找环
* 广度优先
    * 适合有向图找环
* 找环：TC = O(N)



# 搜索
## 写在前面
* 搜索是万金油，解决NP问题的算法
* 定义搜索框架
* 训练代码能力


## 状态与状态空间
* 总结状态、状态空间，把问题抽象为树或图
* 什么是状态？
    * `动态变化`的数据：数量count，当前计数i
* 状态空间：所有`动态变化`的数据集合
    * 以状态为点，如果从一个状态可达另一个状态，加边，构成有向图
    * 对问题的求解，就是对图的遍历
    * 问题的复杂度：当i固定，count已经被决定了，不影响状态规模（简化了状态；一维）
    * 应用：子集（选or不选），全排列（选哪个）
* 搜索 = `直接遍历`整个状态空间的一种算法
    * 一般每个状态只算一次
    * 图：需要`判重（记忆化）`
* 解提步骤
    * 提取信息
    * 模拟状态
    * 确定遍历顺序
    * 定义搜索框架


## DFS 的实现与应用
* 初始化：建立N个数组（出边数组）
* 遍历：先遍历root的出边数组，记录节点是否访问过；`递归`子节点直到无子节点
    * 递归次数和节点数量一致（遍历root算一次）
    * TC = O(N+E)
* DFS：判断无向图是否有环；找联通块
* 对图DFS会产生一棵搜索树：每个节点有一个入口（限制了不能往回走，例如s->a->s并非环），作为其“父节点”


## BFS 的实现与应用
* 入队时标记“已走过”
* push一次，新节点层数加一
* 图的层数：到起点的最短距离
* BFS：判断有向图是否有环————点的度数（连接的所有点的个数）；拓扑排序
    * 有向：出度，入度
* 实战：[207-课程表](https://leetcode-cn.com/problems/course-schedule/)
    * 思路：BFS，入度递减消除先修课限制
    * 如果最后，仍存在入读不为0的点，则有环；如果找不到入度为0的且未访问的点，则有环


## DFS 与 BFS 的`选择`
* 深度优先
    * 问题：树形状态空间，地图类、判重、方向数组
* 广度优先
    * 问题：最小代价、最少步数
    * 任意时刻：队列中只有两层


## DFS 与 BFS 实战
* 最小，最大，最长，最短
    * 最小步数一般用 `BFS` ———— 性质：单调性（分段单调），两段性（每次队列中最多两层）。
    * 图：一个顶点有可能被遍历多次，第一次是最短/最小步数。
    * BFS 起点不唯一
    * 最长：路径不唯一，需要看所有结果
        * `DFS`（时间复杂度非常高；因为有重复计算的子问题）———— 优化：`记忆化`
* [最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)
* [矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)


## 二叉堆
* Heap
    * 高效动态地维护`集合中的最大、最小`
    * `“堆性质”`，所有父与子的关系：大根堆（ge），小根堆（le）
* Binary Heap
    * 是堆的一种实现，满足`堆性质`的`完全二叉树`（堆是树的一种应用）：树高O(logN)
    * 支持删除任意点
    * 一维数组存储（按层编号，root=1 时发现 父*2 和 父*2+1 即子节点编号，root=0 时发现 父*2+1 和 父*2+2 即子节点编号）：O(1)得到下标，节省空间
    * 插入：Heapify Up 直到 root 停止；TC = 树高O(logN)
    * 查询：返回heap[1]，堆顶
    * extract：堆顶与堆尾（这样数组元素无需移动）交换，删除堆尾；root左右较大者，与root交换（直到最后一层节点停止；保证所有点满足堆性质）。

* Priority Queue 
    * 二叉堆是优先队列的一种实现
    * 支持删除堆中任意元素（上下各进行一次堆化；任意——通过在数值和索引建立映射）

* 实战
    * [合并k个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
    * [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
    * [数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)
* Homework
    * [设计推特](https://leetcode-cn.com/problems/design-twitter/)
    * 各自熟悉的语言中`重载比较符号`：实现任意适用于堆



## 二叉搜索树
* Binary Search Tree
    * 性质：任意节点的key >= 左子树所有key && <= 右子树所有key
    * 由此：`中序遍历`是一个`有序`序列
    * 建立：2个保护节点（正无穷right，负无穷root || 正无穷root，负无穷left）；key唯一
        * `重复key`的插入：节点上存一个副本数的filed，copy计数
        * 以上：某些语言支持的？？
    * 搜索：key的value是否存在（=是root，<是搜右子树，>是搜左子树，null是不存在）
        * TC = O(树高)；树高最大是O(N)
    * 插入：存在，放弃/副本数+1；不存在，在检索到的null节点插入
    * （基本用途，支持链表）求前驱/后继：TC = O(树高)；数据随机，期望TC = O(logN)
        * 前驱：小于val的最大节点
        * 后继：大于val的最小节点（右子树左到底 || 检索过程中途经节点们）
        * 依然是基于检索
    * 删除：基于检索 + 求后继
        * 情况一：leaf节点 / 只有一个子节点的节点————可以直接删除
        * 情况二：`有两个子节点`————找到`后继节点`（右子树可以保持不变），后继节点`一定`没有左子树，因此用`右子树`代替

* 实战
    * medium: [701.二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)
    * medium: [面试题0406.后继者](https://leetcode-cn.com/problems/successor-lcci/)
    * medium: [450.删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
    * [538.二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)


