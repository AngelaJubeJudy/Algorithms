# Topic Ⅹ-Ⅲ: Tree Data Structure

## 平衡二叉树：AVL树，红黑树 
* 二叉搜索树
    * key：左更小，右更大
    * 中序遍历必然有序
    * 保证性能的关键：左右子树结点数平衡

* 平衡操作
    * 单旋转（平衡操作基础）：中序遍历顺序不变

* 平衡因子：一个结点的`左`子树高度 - 一个结点的`右`子树高度
* AVL 树
    * 每个结点的平衡因子 ∈ {-1,0,1}
        * 实际：记下当前结点高度（以当前结点为root）
    * 旋转场景一：LL
        * 左左子树：右旋
    * 旋转场景二：RR
        * 右右子树：左旋
    * 旋转场景三：LR
        * 先变回LL型，再右旋
    * 旋转场景四：RL
        * 先变回RR型，再左旋
    * 实战

* 红黑树
    * 近似平衡（不如AVL树更加平衡）
    * 根到叶子的最长路径 <= 2 * 最短路径：高度差在2倍以内（<=2）
    * 黑：root，空NIL
    * 红：不相邻（每条路径不存在两个相邻红结点）；数量少于黑结点。
    * 一个结点到每个叶子结点的所有路径都包含相同数目的黑色结点
    * 规则打破：旋转，变色（两种方式）
    * 比AVL优：插入删除非常快（旋转少），省空间（存颜色，bool；不存高度）
    * 查询略慢
    * 内部类库的有序集合、有序映射的实现方式


## 树堆 Treap
* 基于随机的数据结构
    * 随机：趋于平衡的一种方式
* 旋转

* Treap：每个结点保存的值：key，权值（随机数）
    * 是BST
    * key 满足 BST 性质：左 <= root <= 右
    * 权值（随机数）满足大根堆性质
    * 操作
        * 检索，求前驱&后继————同BST
        * 插入、删除————先检索
            * 新结点：插入后，给一个随机权值（定值）
            * 不满足大根堆性质时：单旋转实现交换


## 跳表
* 对`有序链表`的优化，对标平衡树和二分查找
* TC = O(logN)，原理简单，效率高
    * logN 层索引
    * 每层至多遍历3个结点；最高级索引2个点
* SC = O(N)
    * N/2 + N/4 + N/8 + ... < N
* 构建索引
    * 每k个点，建一个索引：一级、二级、...
* 检索：用索引，从每层索引的头元素开始
    * 停止条件：找到大于等于目标的元素 / 到达索引末尾
* 插入
    * 破坏每个索引2个结点的性质
    * solution：更新索引（因为重建太慢，影响后续索引失效），利用`随机+概率`
* 利用`随机+概率`
    * 构建索引
        * 在原数据中随机 N/2 个元素建立一级索引
        * 在一级索引中随机 N/4 个元素建立二级索引
        * ......
    * 插入
        * “`骰子`”：返回 1~MAX_LEVEL 之间的整数
            * 1/2：插入元数据
            * 1/4：建立一级索引
            * 1/8：更新一级索引，建立二级索引
            * 1/16：更新一级索引、二级索引，建立三级索引



## 树状数组，Binary Indexed Tree / Fenwick Tree 
* 维护`数组`前缀`和`、区间`和`的一种数据结构
* 添加索引，高效维护数组
    * 类比：跳表（链表+索引），添加索引，高效维护链表

* 建立索引
    * 从1开始！！！
    * 以和（sum）为索引
    * 一个结点索引的原始数据数量，与该结点编号在`二进制下最低位的1`有关。
        * 1,3,5,7,...：以1结尾 --> 仅索引1个数据（自身），一级索引
        * 2,6,10,14,...：以10结尾 --> 索引2^1=2个数据（自身+前1个）
        * 4,12,...：以100结尾 --> 索引2^2=4个数据（自身+前3个）
        * 8,...：以1000结尾 --> 索引2^3=8个数据（自身+前7个）
        * 16,...：以10000结尾 --> 索引2^4=16个数据（自身+前15个）

* 二进制分解与 lowbit
    * 原理：任意`正整数`可以`唯一分解`为若干个`不重复`的`2的次幂`之和。
    * 计算：位运算
        * 原理：x AND 0 = 0, NOT x, (NOT x) + 1.
        * `x AND (NOT x + 1) 运算：把最低位1之前的都变成零，之后都变成0。`
        * 计算机用`补码`存储“-x”：((~x)+1) 为x的补码。最高位是符号位。
            * 例：负一表示为“1111”；加一，最高位溢出，结果为“0000”。

    * lowbit(x) 定义：x 在二进制下，最低位的1和后面的0组成的数值（即，`二进制分解下的最小次幂`）
        * 例，lowbit(12) = lowbit(1100_2) = 2^2 = 4.
    * 树状数组 c 的结点 c[x] 存储 x 前面 lowbit(x) 个数据的和，包括 x
        * c[12] = a[9] + a[10] + a[11] + a[12]

* 性质
    * 每个内部节点 c[x] 保存以它为根的子树中所有叶节点的和。
    * 除root外，每个内部节点 c[x] 的父亲是 c[x + lowbit(x)].
    * 树的深度 = O(logN)
    * N不是2的整次幂，那么树状数组就是一个具有上述同样性质的森林结构。

* 操作
    * 递推求 c[x] = query(x-1) + a[x]
    * 查询前缀和：根据整数的二进制分解，可以将任意区间[1,x]分解成 O(logN) 个小区间。
        * 已知前缀和，求区间和[l,r]：query(r) - query(l - 1).
        * TC = O(logN)，循环次数不超过二进制位数；二进制数最多 logN 位。
        * 例：13 = 8+4+1 = 1000_2 + 100_2 + 1_2，则[1,8], [9,12], [13,13]为区间。c[13]仅索引1个数，则[13,13]；c[13-1]索引4个数，则[9,12]；c[13-1-4]索引8个数，则[1,8]；c[13-1-4-8]索引0个（非负个）数，查询结束.
    * 更新
        * ```c++
            void add (int x, int y){
                for(; x <= N; x += x & -x) c[x] += y;
            }
            <!-- x & -x 为 lowbit(x) -->
            ```
        * TC = O(logN)
        * 单点增加：需要更新的索引，从c[x]到它所有的祖先节点；最多O(logN)个。
        * 修改数据：先计算差值，再执行 add 操作。

* 实战
    * [307.区间和检索-数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)-----M

* 局限性
    * 维护的信息需满足“`区间减法性质`”
    * 修改操作不友好
        * 先计算插值，转化为增加操作
        * 难以支持`区间连续数据的修改`


## 线段树，Segment Tree 
* 基于`分治思想`，在区间上进行信息统计
* 结构
    * 每个结点代表一个`闭区间`
    * 每个结点是一个结构：Struct{int left, int right, int data}
    * 具有唯一 root 根：1号点，代表的区间是整个统计范围（如 [1...N]）
    * 每个叶结点代表一个长度为1的元区间 [x...x]
    * 对于每个内部节点 [l...r]：左子节点为 [l, mid]，右子节点为 [mid+1, r]；其中 mid = (l+r)/2，向下取整。
* 性质
    * 除去树的最后一层，整棵线段树一定是一棵完全二叉树。
    * 树的深度 = O(logN)
    * 节点编号：root = 1；编号为p的节点，2p 为左子节点编号，p*2+1 为右子节点。
        * 存储在数组中
        * 没有的节点：跳过，浪费位置，保证编号的规则关系（父子的2倍关系）
    * 最后一层不一定连续：保存线段树的`数组长度不要小于4N`
        * Q：为什么？
        * 1 + ... + 2^k < 2^(k+1) = 2N，最后一层最多 2N；则共不小于4N

* 区间最值问题，Range Maximum Query 
    * 从 l 到 r
    * 支持的操作：维护一个序列，支持查询区间最值，支持单点修改，区间统一修改

* 操作
    * 建树：Build(1,1,n)
        * TC = O(n)，不超过节点数 4n
        * Build(left,right,max)
        * 叶节点：data 为原数据；向上更新父节点的 data，“回溯”
    * 单点修改：Change(1,x,v)
        * TC = O(logN)，从1号出发，更新总次数不超过树高
    * 区间查询：Query(1,l,r)
        * [l,r] 完全覆盖当前节点区间
            * 作为候选直接返回
        * [l,r] 与左/右子节点有重叠，`递归`访问左/右子节点（划分边界）
            * 左子树：右节点
            * 右子树：左节点

* 实战
    * [区间和检索-数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)
    * [一个简单的整数问题2](https://www.acwing.com/problem/content/description/244/)

* 区间修改
    * 完全覆盖的区间：区间修改会影响所有子节点
    * 解决方案：`懒惰标记/延迟标记`
        * 打标记：以后再改，不进入范围（不用）即不会产生影响，下次用之前需要改
        * 遇到标记
        * TC = O(logN)

* 场景设计：`线段覆盖`
    * 调用一：cover(l,r,color)
    * 调用二：query(x)
    * 需求：10万次调用；坐标范围0~1e5


## 离散化
* 场景设计：`线段覆盖`
    * 调用一：cover(l,r,color)
    * 调用二：query(x)
    * 需求：10万次调用；坐标范围，任意实数（double范围内）

* 含义：把无穷集合中的若干元素映射为有限集合，以便维护。
    * 映射为简单正整数，代替复杂数据，开线段树求解
* 场景：坐标压缩
    * 题面：坐标范围0~1e5 == 只有N个坐标有用
    * 算法
        * 排序去重 + 二分
        * 有序集合（sorted set）、有序映射（sorted map）

* 实战
    * [699.掉落的方块](https://leetcode-cn.com/problems/falling-squares/)-----H
    * [区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)


## 各种树形数据结构的对比
* 常考
    * 并查集
        * TC = O(n*α(n))
        * kruskal：排序 logN
    * Trie 树
    * 二叉堆

* 高级：TC = O(n*logn)
    * 树状数组
    * 线段树
    * 平衡二叉搜索树




