# Topic Ⅹ-Ⅰ: Shortest Path, Minimum Spanning Tree

## 图
### 概念
* 由点和边构成的集合。
* 点
    * 有向图：入度，出度
* 边
    * 权值：默认为1
* 环
    * 简单环：从自己出发，经过`不重复`的点和边可以回到自己。
* 连通：图中的任意两个点可以互相到达。
    * 连通块：`极大的`、不能再扩张的连通图。

### 存储
* 邻近矩阵
    * 2维数组：n*n
    * 无权图：有边1，无边0
    * 带权值的图：无边+∞
* 出边数组
    * 接数组：从索引点出发，所有可达点
    * n个变长数组：实现最简洁，但效率不如邻接表
        * 一个元素：二元组，（边，权重）
    * 在数组末尾push新点
* 邻接表
    * 接单链表：从索引点出发，所有可达点
    * 从大到小存储：因为需要在末尾插入新点（避免遍历链表）
    * TC = O(1)，严格

### 遍历
* DFS
    * 产生一棵搜索树
* BFS
    * 按层遍历


## 最短路径
### 单源最短路径问题（SSSP, Single Source Shortest Path）
* 单源问题描述
    * 有向图
    * (x,y,z)：从x出发，到达y，长度为z的有向边。
    * 设置起点x = 1
    * 无权图：求最短路，即`BFS`求层数。
    * 有权图：允许一个点被`遍历多次`的BFS算法，“迭代”思想；最大TC = O(n*m)。

* 常用解法一：Bellman-Ford算法
    * 重复扫描所有(x,y,z)，知道没有更新发生。
    * TC = O(n*m)
    * 若问题有解（即`图中无负环`），最多执行 n-1 轮：TC = O(n)；`一条最短路最多包含 n-1 条边！`（没有点被重复经过）
        * 判断：若`第n轮还能更新`，则存在负环。 
    * 每轮m条边
    * 举例
        * 只需一轮：一条链（取决于边的顺序，正序）
            * 需要 n-1 轮：一条链（倒序）

* 常用解法二：Dijkstra算法
    * 更快的实现，基于贪心算法
    * 初始化：dist[1] = 0，其余+∞
    * 先选未标记的、dist[x]最小点x，然后标记x
    * 从起点到一个点的最短路，在路径中x靠前点最短路`已算过`（无需重复更新，节省时间），当前dist[x]已是最优解。
    * 不断取全局最小的dist[x]更新其他点的最短路；用二叉堆维护dist[x]zuix最小。TC = O(m*log(n))。
    * 堆优化的BFS

* Floyd算法
    * 求每对点之间的最短路
    * TC = O(n^3)
    * 算法本质：动规
    * dp[i,j,k]：经过编号不超过k的点为中继点，从i到j的最短路。
    * 初态：无中继，d为邻接矩阵

* 实战
    * [743.网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)----M
    * [133.阈值距离内邻居最少的城市](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)----M
    * [Dijkstra Benchmark](https://www.acwing.com/problem/content/852/)


## 最小生成树
* 最小生成树问题
    * 边权最小
    * 性质：任意一棵最小生成树一定包含`无向图中权值最小的边`。
    * “生成森林”：若干棵还没相连的树，生成树，一定使用了图中`剩余边中\权值最小的`。
    * 

* Kruskal算法
    * 并查集维护点间关系
    * 初始：n个集合
    * TC = O(n^2*logn)，适合稀疏边

* 优化算法
    * Prim 算法：O(n^2)，满图

* 实战
    * [1584.连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)----M
        * 曼哈顿距离最小生成树    
        * 优化算法：树状数组优化建图 + Kruskal算法：TC = O(n*logn)






