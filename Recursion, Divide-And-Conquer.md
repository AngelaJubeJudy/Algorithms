# Topic Ⅳ: Recursion, Divide-And-Conquer  

## Recursion 递归
### 
* 如何理解？函数自己调用自己，本质通过函数体实现循环。
* 计算n!
    * 问题边界/终止：n = 1
    * n! = n * (n - 1)
* 流程：自顶向下，拆分原问题；自底向上，返回结果
* 3个关键：定义`重叠子问题`--->确定`边界`--->还原现场
* 注：参数和局部变量不需要还原，属于每个函数体；静态变量/全局变量，共享在所有函数体/子问题，需要恢复到递归开始时的状态。
* 实战：子集
    * 子集个数：2^n个
    * 递归：考虑数选或不选
    * 还原现场：set.remove(nums.size() - 1) 
    * `特征：n个选项，每个选项k种抉择。`
* 实战：组合
    * 子集的一种特例
    * 剪枝：？？？
* 实战：全排列
    * 思路：依次考虑每个位置放什么数，在没有用过的数据中选择并放在当前位置。
    * 

### 经典应用：树
* 实战：翻转二叉树（每个子树内部都要翻转）
    * 思路：重叠子问题=每个子树翻转左右节点；边界=叶节点；当前层=翻转左右且验证大小

* 实战：验证二叉搜索树
* 实战：二叉树最深深度


## Divide-And-Conquer 分治
* 关键：子问题的划分——不重不漏
* `当需要划分多段时：第一段必须是一个整体！！！不可分离！！！`







